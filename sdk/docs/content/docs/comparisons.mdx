---
title: Comparisons
---

Superfluid now offers **five** npm packages that serve different layers of the stack.  
Use the matrix below to see which one fits your job.

| Package                                   | Key runtime deps                  | API style                           | Primary role                                      | Recommended when…                                                                 |
|-------------------------------------------|-----------------------------------|-------------------------------------|---------------------------------------------------|-----------------------------------------------------------------------------------|
| **@sfpro/sdk**               | _none_ → optional **viem / wagmi** | Pure functions & generated hooks    | Thin, typesafe contract client                    | You want the lightest possible integration (frontend _or_ backend) and are happy to BYO data layer. |
| **@superfluid-finance/ethereum-contracts** | none                              | JSON ABIs, hard-hat tasks           | Solidity sources & test fixtures                  | You need to compile, fork, or fuzz the protocol contracts.                        |
| **@superfluid-finance/metadata**           | none                              | Static JSON                         | Chain-by-chain addresses & subgraph URLs           | You only need canonical addresses without any helpers.                           |
| **@sfpro/sdk-core**           | **ethers v5, graphql**  | OOP “Framework” + fluent Operations | Full-service SDK with batching, subgraph, events  | You want a batteries-included experience and don’t mind heavier deps.            |
| **@sfpro/sdk-redux**          | **rtk-query, @sfpro/sdk-core**       | RTK Query slices + React hooks      | State-managed RPC/subgraph cache & tx tracker     | You already run Redux and need semi-normalized caching & polling.                     |